This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T21:47:54.619Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.gitignore
.repomixignore
content.js
counter.js
main.js
manifest.json
package.json
popup.html
popup.js
style.css

================================================================
Repository Files
================================================================

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: .repomixignore
================
public
.bolt
readme.md
*.svg
package-lock.json
index.html

================
File: content.js
================
// Flag to track if we're already initialized
let isInitialized = false;
let shouldStop = false;
let batchSize = 10; // Default batch size

// Initialize message listeners
function initialize() {
  if (isInitialized) return;
  
  chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
    console.log('Content script received message:', request);
    
    if (request.action === 'ping') {
      sendResponse({ status: 'ok' });
      return;
    }
    
    if (request.action === 'startScraping') {
      shouldStop = false;
      batchSize = request.batchSize || 10; // Get batch size from request
      console.log('Starting scrape with batch size:', batchSize);
      scrapeMessages(batchSize)
        .then(result => {
          console.log('Scrape complete');
          sendResponse({ status: 'complete' });
        })
        .catch(error => {
          console.error('Scrape failed:', error);
          sendResponse({ status: 'error', error: error.message });
        });
      return true;
    }

    if (request.action === 'stopScraping') {
      console.log('Stopping scrape...');
      shouldStop = true;
      sendResponse({ status: 'stopping' });
    }
  });

  isInitialized = true;
  console.log('WhatsApp scraper content script initialized');
}

function findScrollContainer() {
  const pane = document.querySelector('[data-tab="8"]');
  if (!pane) {
    throw new Error('Chat pane not found - please open a chat');
  }

  let element = pane;
  while (element && element !== document.body) {
    const style = window.getComputedStyle(element);
    if (style.overflowY === 'scroll' || style.overflowY === 'auto') {
      return element;
    }
    element = element.parentElement;
  }

  throw new Error('No scrollable container found');
}

function getChatName() {
  const header = document.querySelector('div#main > header');
  if (!header) return 'whatsapp_chat';
  
  const nameElement = header.children[1].querySelector('div > div > span');
  console.log(nameElement);
  return nameElement ? nameElement.textContent.replace(/[^a-z0-9]/gi, '_').toLowerCase() : 'whatsapp_chat';
}

function extractMessageData(msg) {
  const textElement = msg.querySelector('.copyable-text');
  const isOutgoing = msg.closest('.message-out') !== null;
  
  // Extract timestamp and sender from the data-pre-plain-text attribute
  // Format is typically "[HH:mm, DD/MM/YYYY] Sender Name: "
  const rawPreText = textElement?.getAttribute('data-pre-plain-text') || '';
  const timestampMatch = rawPreText.match(/\[(.*?)\]/);
  const senderMatch = rawPreText.match(/\](.*?):/);  // Get everything between ] and :
  
  const timestamp = timestampMatch ? timestampMatch[1] : '';
  const sender = senderMatch ? senderMatch[1].trim() : (isOutgoing ? 'You' : 'Unknown');
  
  // Get just the message text without the timestamp
  let text = textElement?.textContent?.trim() || '';
  // Remove any timestamp that might be at the end of the text (like "12:55")
  text = text.replace(/\d{1,2}:\d{2}$/, '').trim();
  
  return {
    id: msg.getAttribute('data-id'),
    type: isOutgoing ? 'sent' : 'received',
    sender: sender,
    text: text,
    timestamp: timestamp
  };
}

async function saveBatch(messages, batchNumber) {
  return new Promise((resolve, reject) => {
    chrome.runtime.sendMessage({
      action: 'downloadBatch',
      messages: messages,
      batchNumber: batchNumber,
      chatName: getChatName() // Add chat name to the message
    }, response => {
      if (chrome.runtime.lastError) {
        reject(chrome.runtime.lastError);
      } else {
        resolve(response);
      }
    });
  });
}

async function scrapeMessages(batchSize = 10) {
  let messages = [];
  let processedIds = new Set();
  let batchNumber = 1;

  console.log('Finding scroll container...');
  const scrollContainer = findScrollContainer();
  console.log('Found container:', scrollContainer);

  let noNewMessagesCount = 0;
  const MAX_ATTEMPTS = 3;
  
  while (noNewMessagesCount < MAX_ATTEMPTS && !shouldStop) {
    const beforeScroll = scrollContainer.scrollTop;
    const beforeHeight = scrollContainer.scrollHeight;
    
    scrollContainer.scrollTop -= 1000;
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    const messageElements = document.querySelectorAll('[data-id]');
    let foundNewMessages = false;

    for (const msg of messageElements) {
      if (shouldStop) break;
      
      const messageId = msg.getAttribute('data-id');
      if (!processedIds.has(messageId)) {
        processedIds.add(messageId);
        foundNewMessages = true;
        
        messages.push(extractMessageData(msg));

        // If we hit batch size, save and clear
        if (messages.length >= batchSize) {
          console.log(`Batch ${batchNumber} full, saving...`);
          await saveBatch(messages, batchNumber);
          messages = [];  // Clear the array
          batchNumber++;
        }
      }
    }

    console.log('Scroll cycle:', {
      scrollDelta: beforeScroll - scrollContainer.scrollTop,
      heightDelta: scrollContainer.scrollHeight - beforeHeight,
      newMessages: foundNewMessages,
      currentBatchSize: messages.length,
      totalProcessed: processedIds.size
    });

    if (!foundNewMessages && beforeScroll === scrollContainer.scrollTop) {
      noNewMessagesCount++;
      console.log(`No changes detected, attempt ${noNewMessagesCount} of ${MAX_ATTEMPTS}`);
    } else {
      noNewMessagesCount = 0;
    }
  }

  // Save any remaining messages
  if (messages.length > 0) {
    await saveBatch(messages, batchNumber);
  }

  const reason = shouldStop ? 'stopped by user' : 'completed';
  console.log(`Scraping ${reason}, processed`, processedIds.size, 'total messages');
}

// Initialize when loaded
initialize();
console.log('Content script loaded');

================
File: counter.js
================
export function setupCounter(element) {
  let counter = 0
  const setCounter = (count) => {
    counter = count
    element.innerHTML = `count is ${counter}`
  }
  element.addEventListener('click', () => setCounter(counter + 1))
  setCounter(0)
}

================
File: main.js
================
import './style.css'
import javascriptLogo from './javascript.svg'
import viteLogo from '/vite.svg'
import { setupCounter } from './counter.js'

document.querySelector('#app').innerHTML = `
  <div>
    <a href="https://vitejs.dev" target="_blank">
      <img src="${viteLogo}" class="logo" alt="Vite logo" />
    </a>
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank">
      <img src="${javascriptLogo}" class="logo vanilla" alt="JavaScript logo" />
    </a>
    <h1>Hello Vite!</h1>
    <div class="card">
      <button id="counter" type="button"></button>
    </div>
    <p class="read-the-docs">
      Click on the Vite logo to learn more
    </p>
  </div>
`

setupCounter(document.querySelector('#counter'))

================
File: manifest.json
================
{
  "manifest_version": 3,
  "name": "WhatsApp Chat Scraper",
  "version": "1.0",
  "description": "Scrapes chat history from WhatsApp Web",
  "permissions": [
    "activeTab",
    "scripting",
    "storage",
    "downloads"
  ],
  "host_permissions": [
    "https://web.whatsapp.com/*"
  ],
  "action": {
    "default_popup": "popup.html"
  },
  "content_scripts": [{
    "matches": ["https://web.whatsapp.com/*"],
    "js": ["content.js"],
    "run_at": "document_idle"
  }]
}

================
File: package.json
================
{
  "name": "vite-starter",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "vite": "^5.4.2"
  }
}

================
File: popup.html
================
<!DOCTYPE html>
<html>
<head>
  <style>
    :root {
      --whatsapp-teal: #25D366;
      --whatsapp-teal-dark: #128C7E;
      --whatsapp-light-bg: #DCF8C6;
      --text-primary: #075E54;
    }

    body {
      width: 320px;
      padding: 0;
      margin: 0;
      font-family: system-ui, -apple-system, sans-serif;
      background: #fff;
      color: var(--text-primary);
    }

    .header {
      background: linear-gradient(135deg, var(--whatsapp-teal-dark), var(--whatsapp-teal));
      padding: 20px;
      color: white;
      text-align: center;
      position: relative;
      overflow: hidden;
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .header::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(45deg, transparent 45%, rgba(255,255,255,0.1) 50%, transparent 55%);
      animation: shine 3s infinite;
      background-size: 200% 200%;
    }

    @keyframes shine {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .title {
      font-size: 24px;
      font-weight: 700;
      margin: 0;
      text-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .subtitle {
      font-size: 14px;
      opacity: 0.9;
      margin: 4px 0 0 0;
    }

    .container {
      padding: 16px;
    }

    .settings-card {
      background: white;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      border: 1px solid rgba(0,0,0,0.1);
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .settings-card:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .card-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-primary);
      margin: 0 0 12px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .setting-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 8px;
      transition: background-color 0.2s;
    }

    .setting-row:hover {
      background: #f0f2f5;
    }

    .setting-row:last-child {
      margin-bottom: 0;
    }

    input[type="number"] {
      width: 70px;
      border: 2px solid var(--whatsapp-teal);
      border-radius: 6px;
      padding: 6px 8px;
      font-size: 14px;
      outline: none;
      transition: all 0.2s;
    }

    input[type="number"]:focus {
      border-color: var(--whatsapp-teal-dark);
      box-shadow: 0 0 0 3px rgba(37, 211, 102, 0.1);
    }

    .export-options {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .format-option {
      position: relative;
    }

    .format-option input[type="radio"] {
      display: none;
    }

    .format-option label {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px;
      background: #f0f2f5;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .format-option input[type="radio"]:checked + label {
      background: var(--whatsapp-teal);
      color: white;
    }

    .action-buttons {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 8px;
      margin-top: 16px;
    }

    button {
      padding: 12px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    #startScraping {
      background: var(--whatsapp-teal);
      color: white;
    }

    #startScraping:hover:not(:disabled) {
      background: var(--whatsapp-teal-dark);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(37, 211, 102, 0.2);
    }

    #startScraping:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    #stopScraping {
      background: #ef4444;
      color: white;
    }

    #stopScraping:hover:not(:disabled) {
      background: #dc2626;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
    }

    #stopScraping:disabled {
      background: #fca5a5;
      cursor: not-allowed;
    }

    .status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 12px;
      padding: 8px;
      border-radius: 8px;
      background: #f8f9fa;
      font-size: 13px;
    }

    .status.running {
      background: var(--whatsapp-light-bg);
      color: var(--whatsapp-teal-dark);
    }

    .spinner {
      width: 16px;
      height: 16px;
      border: 2px solid var(--whatsapp-teal);
      border-top-color: transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    .running .spinner {
      display: block;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1 class="title">WAScraper Pro</h1>
    <p class="subtitle">Professional Chat Export Tool</p>
  </div>

  <div class="container">
    <div class="settings-card">
      <div class="card-title">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/>
          <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1Z"/>
        </svg>
        Scraping Settings
      </div>
      <div class="setting-row">
        <label for="batchSize">Batch Size:</label>
        <input type="number" id="batchSize" min="1" max="100" value="10">
      </div>
      <div class="setting-row">
        <label>
          <input type="checkbox" id="includeTimestamps" checked>
          Include timestamps
        </label>
      </div>
      <div class="setting-row">
        <label>
          <input type="checkbox" id="includeSenderInfo" checked>
          Include sender information
        </label>
      </div>
    </div>

    <div class="settings-card">
      <div class="card-title">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
          <polyline points="7 10 12 15 17 10"/>
          <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        Export Format
      </div>
      <div class="export-options">
        <div class="format-option">
          <input type="radio" id="formatJson" name="exportFormat" value="json" checked>
          <label for="formatJson">JSON</label>
        </div>
        <div class="format-option">
          <input type="radio" id="formatCsv" name="exportFormat" value="csv">
          <label for="formatCsv">CSV</label>
        </div>
        <div class="format-option">
          <input type="radio" id="formatTxt" name="exportFormat" value="txt">
          <label for="formatTxt">Text</label>
        </div>
      </div>
    </div>

    <div class="action-buttons">
      <button id="startScraping">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M5 3v4M3 5h4M6 17v4M4 19h4M13 3l3.293 3.293a1 1 0 0 1 0 1.414l-9.9 9.9a1 1 0 0 1-1.414 0L2 14.5M21 21l-3.293-3.293a1 1 0 0 1 0-1.414l9.9-9.9a1 1 0 0 1 1.414 0L32 9.5"/>
        </svg>
        Start Scraping
      </button>
      <button id="stopScraping" disabled>Stop</button>
    </div>

    <div class="status">
      <div class="spinner"></div>
      <span id="status">Ready to scrape...</span>
    </div>
  </div>

  <script src="popup.js"></script>
</body>
</html>

================
File: popup.js
================
// Helper functions for different export formats
function formatMessagesAsCSV(messages, options) {
  const headers = ['Message'];
  if (options.includeTimestamps) headers.unshift('Timestamp');
  if (options.includeSenderInfo) headers.unshift('Sender');
  
  const rows = messages.map(msg => {
    const row = [msg.text];
    if (options.includeTimestamps) row.unshift(msg.timestamp);
    if (options.includeSenderInfo) row.unshift(msg.sender);
    return row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',');
  });
  
  return [headers.join(','), ...rows].join('\n');
}

function formatMessagesAsText(messages, options) {
  return messages.map(msg => {
    const parts = [msg.text];
    if (options.includeTimestamps) parts.unshift(`[${msg.timestamp}]`);
    if (options.includeSenderInfo) parts.unshift(msg.sender + ':');
    return parts.join(' ');
  }).join('\n');
}

// Global variables for event handlers
let globalDownloadHandler = null;

document.addEventListener('DOMContentLoaded', async () => {
  // Get DOM elements
  const startButton = document.getElementById('startScraping');
  const stopButton = document.getElementById('stopScraping');
  const statusDiv = document.getElementById('status');
  const batchSizeInput = document.getElementById('batchSize');
  const includeTimestamps = document.getElementById('includeTimestamps');
  const includeSenderInfo = document.getElementById('includeSenderInfo');
  const exportFormatInputs = document.querySelectorAll('input[name="exportFormat"]');

  let isRunning = false;

  // Load saved settings
  async function loadSettings() {
    const settings = await chrome.storage.sync.get({
      batchSize: 10,
      includeTimestamps: true,
      includeSenderInfo: true,
      exportFormat: 'json'
    });

    batchSizeInput.value = settings.batchSize;
    includeTimestamps.checked = settings.includeTimestamps;
    includeSenderInfo.checked = settings.includeSenderInfo;
    document.querySelector(`input[value="${settings.exportFormat}"]`).checked = true;
  }

  // Save settings when changed
  async function saveSettings() {
    const settings = {
      batchSize: parseInt(batchSizeInput.value),
      includeTimestamps: includeTimestamps.checked,
      includeSenderInfo: includeSenderInfo.checked,
      exportFormat: document.querySelector('input[name="exportFormat"]:checked').value
    };

    await chrome.storage.sync.set(settings);
  }

  // Add change listeners to all settings
  [batchSizeInput, includeTimestamps, includeSenderInfo]
    .forEach(element => element.addEventListener('change', saveSettings));
  
  exportFormatInputs.forEach(input => 
    input.addEventListener('change', saveSettings)
  );

  async function updateButtons(running) {
    isRunning = running;
    startButton.disabled = running;
    stopButton.disabled = !running;
    batchSizeInput.disabled = running;
    
    // Disable settings during scraping
    includeTimestamps.disabled = running;
    includeSenderInfo.disabled = running;
    exportFormatInputs.forEach(input => input.disabled = running);
  }

  function getExportOptions() {
    return {
      format: document.querySelector('input[name="exportFormat"]:checked').value,
      includeTimestamps: includeTimestamps.checked,
      includeSenderInfo: includeSenderInfo.checked
    };
  }

  // Remove existing download handler if it exists
  function cleanupDownloadHandler() {
    if (globalDownloadHandler) {
      chrome.runtime.onMessage.removeListener(globalDownloadHandler);
      globalDownloadHandler = null;
    }
  }

  // Setup download handler
  function setupDownloadHandler() {
    cleanupDownloadHandler();
    
    globalDownloadHandler = (request, sender, sendResponse) => {
      if (request.action === 'downloadBatch') {
        const exportOptions = getExportOptions();
        const messages = request.messages;
        
        let blob;
        let extension;
        
        switch(exportOptions.format) {
          case 'json':
            blob = new Blob([JSON.stringify(messages, null, 2)], { 
              type: 'application/json' 
            });
            extension = 'json';
            break;
            
          case 'csv':
            const csvContent = formatMessagesAsCSV(messages, exportOptions);
            blob = new Blob([csvContent], { type: 'text/csv' });
            extension = 'csv';
            break;
            
          case 'txt':
            const txtContent = formatMessagesAsText(messages, exportOptions);
            blob = new Blob([txtContent], { type: 'text/plain' });
            extension = 'txt';
            break;
        }
        
        chrome.downloads.download({
          url: URL.createObjectURL(blob),
          filename: `${request.chatName}_batch_${request.batchNumber}.${extension}`,
          saveAs: false
        }, () => {
          sendResponse({ status: 'downloaded' });
        });
        
        statusDiv.textContent = `Downloaded batch ${request.batchNumber}...`;
        return true;
      }
    };

    chrome.runtime.onMessage.addListener(globalDownloadHandler);
  }

  startButton.addEventListener('click', async () => {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    
    if (!tab.url.includes('web.whatsapp.com')) {
      statusDiv.textContent = 'Please open WhatsApp Web first';
      return;
    }

    try {
      updateButtons(true);
      statusDiv.textContent = 'Scraping in progress...';
      
      // Setup download handler before starting
      setupDownloadHandler();
      
      // Check content script connection
      try {
        const pingResponse = await chrome.tabs.sendMessage(tab.id, { action: 'ping' });
        console.log('Content script is ready:', pingResponse);
      } catch (e) {
        console.log('Content script not ready, injecting...');
        await chrome.scripting.executeScript({
          target: { tabId: tab.id },
          files: ['content.js']
        });
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // Start scraping with current settings
      chrome.tabs.sendMessage(tab.id, { 
        action: 'startScraping',
        batchSize: parseInt(batchSizeInput.value),
        options: getExportOptions()
      }, response => {
        if (chrome.runtime.lastError) {
          console.error('Error:', chrome.runtime.lastError);
          statusDiv.textContent = 'Error: Could not connect to page. Try refreshing WhatsApp Web.';
          updateButtons(false);
          return;
        }
        
        if (response && response.status === 'complete') {
          statusDiv.textContent = 'Scraping complete!';
          updateButtons(false);
        } else if (response && response.status === 'error') {
          statusDiv.textContent = `Error: ${response.error}`;
          updateButtons(false);
        }
      });
    } catch (error) {
      console.error('Error:', error);
      statusDiv.textContent = 'Error: ' + error.message;
      updateButtons(false);
    }
  });

  stopButton.addEventListener('click', async () => {
    const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
    chrome.tabs.sendMessage(tab.id, { action: 'stopScraping' }, response => {
      if (response && response.status === 'stopping') {
        statusDiv.textContent = 'Stopping scrape...';
      }
    });
  });

  // Initialize
  await loadSettings();
  updateButtons(false);
});

================
File: style.css
================
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

#app {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vanilla:hover {
  filter: drop-shadow(0 0 2em #f7df1eaa);
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
